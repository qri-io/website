<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta name="generator" content="Hugo 0.44" />
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> Starlark Transformations </title>

  
  
  
  
  
  

  

  <meta name="author" content="qri">


  <meta property="og:title" content="Starlark Transformations" />
<meta property="og:description" content="Starlark Transformations Qri (&ldquo;query&rdquo;) is about datasets. A transformation is a repeatable script for generating a dataset. Starlark. This package implements starlark as a transformation syntax. Starlark transformations are about as close as one can get to the full power of a programming language as a transformation syntax. Often you need this degree of control to generate a dataset.
Typical examples of a starlark transformation include:
 combining paginated calls to an API into a single dataset downloading unstructured structured data from the internet to extract  So let&rsquo;s dive in and learn about transforms!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qri.io/docs/tutorials/starlark_transformations/" />



<meta property="article:published_time" content="2018-01-30T00:00:00-04:00"/>

<meta property="article:modified_time" content="2018-01-30T00:00:00-04:00"/>











  




  
  
  
  
  

  <link rel="canonical" href="https://qri.io/docs/tutorials/starlark_transformations/">  

  <link href="../../../favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="../../../css/font.css" rel="stylesheet" type="text/css">
  <link href="../../../css/qri.css" rel="stylesheet" type="text/css">
  

  <script src="../../../js/jquery-2.1.4.min.js" type="text/javascript"></script>
  <link rel="stylesheet" href="../../../css/highlight.default.min.css">
  <link rel="stylesheet" href="../../../css/highlight.theme.tomorrow.css">
  <script src="../../../js/highlight.pack.js"></script>
  <script>
    window.onload = function(e) {
      let elements = document.querySelectorAll('.highlight pre')
      Array.from(elements).forEach((block, i) => {
        hljs.highlightBlock(block)
      })
    }
  </script>

  <script type="text/javascript" src="../../../js/tocbot.min.js"></script>

  
    <script type="text/javascript">
     !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
      analytics.load("b4iAxJT8ISitRFQ6qZGS9w7RTnaOpvju");
      analytics.page()
    }}();
    </script>
  
</head>


<body class="page-kube docs " >
  <header></header>
  <main>
<div id="docs_page" class="docs">
  <div id="docs_sidebar_toggle">
  <div class="icon">
    <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
    viewBox="0 0 10 10" style="enable-background:new 0 0 10 10;" xml:space="preserve">
      <style type="text/css">
        .st0{fill:#FFFFFF;}
      </style>
      <path class="st0" d="M9,2.3H1c-0.44,0-0.8-0.36-0.8-0.8V1.3c0-0.44,0.36-0.8,0.8-0.8H9c0.44,0,0.8,0.36,0.8,0.8V1.5
        C9.8,1.94,9.44,2.3,9,2.3z"/>
      <path class="st0" d="M9,5.9H1c-0.44,0-0.8-0.36-0.8-0.8V4.9c0-0.44,0.36-0.8,0.8-0.8H9c0.44,0,0.8,0.36,0.8,0.8V5.1
        C9.8,5.54,9.44,5.9,9,5.9z"/>
      <path class="st0" d="M9,9.5H1c-0.44,0-0.8-0.36-0.8-0.8V8.5c0-0.44,0.36-0.8,0.8-0.8H9c0.44,0,0.8,0.36,0.8,0.8V8.7
        C9.8,9.14,9.44,9.5,9,9.5z"/>
    </svg>
  </div>
</div>
<nav id="docs_sidebar">
  <div class="content">
    <div class="logotype">
      <a href="../../../" title="home" class="title">qri</a>
      <p class="subhead">docs</p>
    </div>
    <div class="pages">
      <ul>
      
        
          
            <li class="section"><a href="../../../docs/concepts/"><h5>concepts</h5></a></li>
            <ul>
              
                <li class="page"><a href="../../../docs/concepts/content-addressing/">Content Addressing</a></li>
              
                <li class="page"><a href="../../../docs/concepts/dataset/">Datasets</a></li>
              
                <li class="page"><a href="../../../docs/concepts/distributed-storage/">Distributed Storage</a></li>
              
                <li class="page"><a href="../../../docs/concepts/names/">Naming</a></li>
              
                <li class="page"><a href="../../../docs/concepts/overview/">Overview</a></li>
              
            </ul>
          
            <li class="section"><a href="../../../docs/reference/"><h5>reference</h5></a></li>
            <ul>
              
                <li class="page"><a href="../../../docs/reference/starlib/">Starlark Std. Library</a></li>
              
                <li class="page"><a href="../../../docs/reference/cli_commands/">CLI commands</a></li>
              
                <li class="page"><a href="../../../docs/reference/dataset/">Dataset</a></li>
              
                <li class="page"><a href="../../../docs/reference/starlark_syntax/">Starlark Language</a></li>
              
            </ul>
          
            <li class="section"><a href="../../../docs/tutorials/"><h5>tutorials</h5></a></li>
            <ul>
              
                <li class="page"><a href="../../../docs/tutorials/cli_quickstart/">CLI quickstart</a></li>
              
                <li class="page"><a href="../../../docs/tutorials/starlark_transformations/">Starlark Transformations</a></li>
              
            </ul>
          
        
      
        
      
        
      
        
      
      </ul>
    </div>
  </div>
  <br />
</nav>
  <section id="main">
    <div class="content">
      

<h1 id="starlark-transformations">Starlark Transformations</h1>

<p>Qri (&ldquo;query&rdquo;) is about datasets. A <em>transformation</em> is a repeatable script for generating a dataset. <a href="https://github.com/google/starlark/blob/master/doc/spec.md">Starlark</a>. This package implements starlark as a <em>transformation syntax</em>. Starlark transformations are about as close as one can get to the full power of a programming language as a transformation syntax. Often you need this degree of control to generate a dataset.</p>

<p>Typical examples of a starlark transformation include:</p>

<ul>
<li>combining paginated calls to an API into a single dataset</li>
<li>downloading unstructured structured data from the internet to extract</li>
</ul>

<p>So let&rsquo;s dive in and learn about transforms!</p>

<h1 id="table-of-contents">Table of Contents</h1>

<h4 id="1-transformation-basics">1. Transformation Basics</h4>

<ul>
<li><a href="#1_1">1.1 - What&rsquo;s a Transformation?</a><br /></li>
<li><a href="#1_2">1.2 - Manual Transforms</a><br /></li>
<li><a href="#1_3">1.3 - Scripted Transforms</a></li>
<li><a href="#1_4">1.4 - The Transform Function</a></li>
</ul>

<h4 id="2-transforms-that-download-data">2. Transforms that Download Data</h4>

<ul>
<li><a href="#2_1">2.1 - Download function</a></li>
<li><a href="#2_2">2.2 - Config and Secrets</a></li>
<li><a href="#2_3">2.3 - Modules and <code>qri</code></a></li>
<li><a href="#2_4">2.4 - http</a></li>
<li><a href="#2_5">2.5 - html</a>
<!-- * [2.6 - Automating Updates](#2_6) --></li>
</ul>

<!--
### 3 Mixing Manual & Scripted Transforms
* [1.5 - Transforms & Histories](#1_5)
#### 4. One-off Scripts
#### 5. Combining Datasets 
-->

<hr />

<p><a id="1_1"></a></p>

<h3 id="1-1-what-s-a-transformation">1.1 What&rsquo;s a Transformation?</h3>

<p>Before we get started, let&rsquo;s understand what we mean by &ldquo;transform&rdquo;. Here&rsquo;s the technical definition of a transform in Qri:</p>

<p><strong>A Transformation is a forward transition from one snapshot to another snapshot.</strong></p>

<p>In plain English: transformations are how datasets change. There are two types of transformation: <em>manual</em> and <em>scripted</em>. Manual transforms are direct manipulations of data, scripted transformations use code to make changes.</p>

<p>There are some rules to how transformations work:</p>

<ul>
<li>transforms must mutate one or more non-computed fields of a dataset</li>
<li>only one type of transform can be applied to any field per transform</li>
<li>transforms can use one or more types of mutations to determine the next snapshot</li>
</ul>

<p>It&rsquo;s totally ok if that sounds like nonsense for now. We&rsquo;ll be walking through all of this with real examples in this tutorial.</p>

<p><a id="1_2"></p>

<h3 id="1-2-manual-transforms">1.2 Manual Transforms</h3>

<p>Before getting into scripts, let&rsquo;s create a dataset using only manual transformations. Manual transforms work by providing values directly to Qri. Let&rsquo;s start by manually creating a dataset. First we&rsquo;ll create a new (very simple) json file: an array of rational numbers called <code>body.json</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span></code></pre></div>
<p>Next in the same folder we&rsquo;ll create a new file called <code>dataset.yaml</code> with the following contents:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml">name<span class="p">:</span><span class="w"> </span>rational_numbers<span class="w">
</span><span class="w"></span>meta<span class="p">:</span><span class="w">
</span><span class="w">  </span>title<span class="p">:</span><span class="w"> </span>rational<span class="w"> </span>number<span class="w"> </span>series<span class="w">
</span><span class="w"></span>bodypath<span class="p">:</span><span class="w"> </span>body.json</code></pre></div>
<p>From a terminal, navigate to the folder that contains that file, and save it to Qri with <code>qri save</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">$ cd path/to/that_folder
$ qri save --file=dataset.yaml
saved dataset b5/rational_numbers</code></pre></div>
<p>Ok cool, you&rsquo;ve just created a new dataset with a manual transformation that lists rational numbers. It&rsquo;s &ldquo;manual&rdquo; because you provided values directly to Qri. The &ldquo;transform part&rdquo; transitioned from nothing (an empty dataset) to a an initial snapshot of a datset.</p>

<p><a id="1_3"></p>

<h3 id="1-3-transform-scripts">1.3 Transform Scripts</h3>

<p>We can think of the above manual transform as a series of <em>assignments</em> in a single <em>function call</em>. Written out as code, above example is telling Qri to do the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">human_transform</span><span class="p">(</span><span class="n">ds</span><span class="p">):</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s2">&#34;title&#34;</span><span class="p">,</span> <span class="s2">&#34;rational number series&#34;</span><span class="p">)</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">set_body</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span></code></pre></div>
<p>When you save a dataset, qri calls up the previous version (or crates an empty dataset when there is no previous version), and then applies all the changes provided to get to a new version.</p>

<p>There are <em>many</em> situations where manual transforms are the right option (or the only option) for changing a dataset. But we&rsquo;re using a computer, and if we can describe the changes we want to make as code, the computer can do more work for us. That&rsquo;s where transform scripts come in.</p>

<p>With a transform script, instead of making manual changes, an algorithm <em>automates</em> changes to fields of a dataset with programmatic instructions.</p>

<p>Before we get into what&rsquo;s going on, let&rsquo;s actually try this out.</p>

<p>Transform scripts are written in <em>starlark</em>. Starlark is a subset of python, so if you can write python, you can write starlark. If you can&rsquo;t write python (or starlark), that&rsquo;s ok! We&rsquo;ll circle back later &amp; explain the transform function, but for now let&rsquo;s just copy-paste our way to victory. From the same folder, create a new file called <code>transform.star</code> and save this into it:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s2">&#34;title&#34;</span><span class="p">,</span> <span class="s2">&#34;rational number series&#34;</span><span class="p">)</span>
  <span class="c1"># use the range function to automate setting the dataset body</span>
  <span class="c1"># range(1,11) will produce an array of numbers: [1,2,3,4,5,6,7,9,10]</span>
  <span class="c1"># which is the same as our manual transform, but with less typing!</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">set_body</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span></code></pre></div>
<p><em>note: if you&rsquo;re using a text editor and want syntax highlighting (colored text), try setting your editor to &lsquo;python&rsquo; syntax.</em></p>

<p>This is a script that does the exact same thing as our manual transform from earlier. To use the script, let&rsquo;s modify our <code>dataset.yaml</code> use the script, deleting the <code>meta</code> and <code>body</code> components, and adding a new <code>transform</code> component that specifies our script file. Once <code>dataset.yaml</code> looks like this, save the file:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml">name<span class="p">:</span><span class="w"> </span>rational_numbers<span class="w">
</span><span class="w"></span>transform<span class="p">:</span><span class="w">
</span><span class="w">  </span>scriptpath<span class="p">:</span><span class="w"> </span>transform.yaml</code></pre></div>
<p>You can delete stuff in this file, because it&rsquo;s stored in Qri!</p>

<p>Now let&rsquo;s save a new snapshot to qri:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">$ qri save --file dataset.yaml
error saving: no changes detected</code></pre></div>
<p>Wait, we got an error. what gives? This is because the result of running the transform <em>didn&rsquo;t change the dataset</em>. Transforms have to describe <em>changes</em>. This is a super important feature of Qri, and transforms. If nothing changes, Qri can tell you as much, and avoid creating unnecessary versions of a dataset.</p>

<p>To get this to work, let&rsquo;s change something! Let&rsquo;s open up our <code>transform.star</code> file and write a script that adds more numbers to our body:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s2">&#34;title&#34;</span><span class="p">,</span> <span class="s2">&#34;rational number series&#34;</span><span class="p">)</span>
  <span class="c1"># this time set the body to 1-1000 instead:</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">set_body</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1001</span><span class="p">))</span></code></pre></div>
<p>And re-run save:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">$ qri save --file dataset.yaml
dataset saved: b6/rational_numbers@QmQ7hA8gk...</code></pre></div>
<p>Congrats! you&rsquo;ve just run a transform with a dataset of the numbers 1 to 1000, without having to type the numbers by hand.</p>

<p><a id="1_4"></p>

<h3 id="the-transform-function">The transform function</h3>

<p>Ok, we can&rsquo;t avoid the issue any longer, time to understand what&rsquo;s going on in this script:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">set_meta</span><span class="p">(</span><span class="s2">&#34;title&#34;</span><span class="p">,</span> <span class="s2">&#34;rational number series&#34;</span><span class="p">)</span>
  <span class="c1"># this time set the body to 1-1000 instead:</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">set_body</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1001</span><span class="p">))</span></code></pre></div>
<p>This script defines a <em>special function</em>: <code>transform</code> that Qri knows to look for. There are others, but <code>transform</code> is the main one (literally, if you&rsquo;re coming from an engineering background, <code>transform</code> is Qri&rsquo;s <code>main</code>). The transform function accepts two <em>arguments</em>: <code>ds</code> and <code>ctx</code>:
* ds represents the current <em>dataset snapshot</em>. Your mission, should you choose to accept it, is to change <code>ds</code> in some way
* ctx represents the <em>transform context</em>, it keeps info used while the transform script is running.</p>

<p>When we run <code>qri save</code> with a transform script specified, Qri will load it up and look for the transform function, which must be defined. When Qri finds that function, it loads up the existing version of the dataset (or makes an empty dataset if there&rsquo;s no history), and passes it to ds. Whatever changes are made to ds via method calls like <code>set_body</code> and <code>set_meta</code> are applied to the dataset, and the result is committed as a new snapshot.</p>

<p>Its possible to mix manual transforms and scripted transforms, but they can&rsquo;t affect the same parts of a dataset. We&rsquo;ll cover mixing transform types in another tutorial.</p>

<hr />

<p><a id="2_0"></a></p>

<h2 id="2-transforms-that-download-data-1">2. Transforms that Download Data</h2>

<p>Transforms have another <em>special function</em> called <code>download</code> that lets you create super-powered datasets that draw from the world wide web. <code>download</code> can do all sorts of stuff like grab resources from APIs, fetch &amp; parse HTML, or pull raw <code>csv</code> data off the web. Combined with Qri versioning, you can make a dataset that knows how to update itself, and only records updates when the external resource changes.</p>

<p><a id="2_1"></a></p>

<h2 id="2-1-download-function">2.1 Download function</h2>

<p>In this section we are going to talk about the Qri function <code>download</code>. The <code>download</code> function is a <em>special function</em> that gives your script access to the internet. The <code>download</code> function is the <em>only</em> place where you have access to the web.</p>

<p>The <code>download</code> function is always run before the <code>transform</code> step, and places it&rsquo;s results in the <em>transform context</em>. The dataset returned from the <code>download</code> function, gets passed as the dataset parameter in the <code>transform</code> function.</p>

<p><a id="2_2"></a></p>

<h2 id="2-2-config-and-secrets">2.2 Config and Secrets</h2>

<p>When we came up with the idea of including transforms in Qri, the thing we were most excited about was a transforms ability to be customized for the person running it. In order to have customizability, we needed a way to <em>configure</em> a transform script. For example, if there is a dataset that has a call to the github api, that can pull down the stats from one of my projects, but I want to also use that transform to pull down stats from a second project, one of the variables in my transform would probably be <code>repo_name</code>.</p>

<p>Related to configuration are <em>secrets</em>. Often, when we try to get information from an api, that api requires us to have a special key that is only associated with our identity. It&rsquo;s often private and should not be shared in the dataset itself or made public in any way.</p>

<p>This is where the config and secrets comes in. <code>config</code> and <code>secrets</code> are both part of the transform dataset component.</p>

<p>To illustrate, we&rsquo;ll build an example that grabes the last 100 League of Legends matches a specific player (in this case called <code>summoner</code>) has played in a specific region (in this case, North America). Let&rsquo;s create a new folder called <code>lol_last_100_matches</code>, and a new <code>dataset.yaml</code> file within that folder:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># lol_last_100_matches/dataset.yaml</span><span class="w">
</span><span class="w"></span>name<span class="p">:</span><span class="w"> </span>league_player_matches<span class="w">
</span><span class="w"></span>meta<span class="p">:</span><span class="w">
</span><span class="w">  </span>title<span class="p">:</span><span class="w"> </span>Dataset<span class="w"> </span>created<span class="w"> </span>using<span class="w"> </span>the<span class="w"> </span>qri<span class="w"> </span>starlark<span class="w"> </span>tutorial.<span class="w"> </span>Pings<span class="w"> </span>the<span class="w"> </span>Riot<span class="w"> </span>Games<span class="w"> </span>(creator<span class="w"> </span>of<span class="w"> </span>the<span class="w"> </span>computer<span class="w"> </span>game<span class="w"> </span>League<span class="w"> </span>of<span class="w"> </span>Legends)<span class="w"> </span>api<span class="p">,</span><span class="w"> </span>gets<span class="w"> </span>a<span class="w"> </span>summoner&#39;s<span class="w"> </span>account<span class="w"> </span>id<span class="p">,</span><span class="w"> </span>and<span class="w"> </span>then<span class="w"> </span>a<span class="w"> </span>list<span class="w"> </span>of<span class="w"> </span>their<span class="w"> </span>last<span class="w"> </span><span class="m">100</span><span class="w"> </span>matches.<span class="w">
</span><span class="w"></span>transform<span class="p">:</span><span class="w">
</span><span class="w">  </span>scriptpath<span class="p">:</span><span class="w"> </span>transform.star<span class="w">
</span><span class="w">  </span>config<span class="p">:</span><span class="w">
</span><span class="w">    </span>summoner<span class="p">:</span><span class="w"> </span>sørenbjerg<span class="w">
</span><span class="w">    </span>region<span class="p">:</span><span class="w"> </span>na1</code></pre></div>
<p>Config is set right on the transform component. Secrets, on the other hand, should be provided when calling the command:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">$ qri save --file=dataset.yaml --secrets=api_key,*******************</code></pre></div>
<p>Note, if you want to run this transform yourself, you will need to head over to the <a href="https://developer.riotgames.com/">Riot Games developer website</a>, and create a login. Then, you can generate your own api key right from your developer dashboard. You will replace the series of <code>*****</code> in the command with your own api key.</p>

<p>Okay, so that&rsquo;s how you add a config variable and a secrets variable into the transform, but how do you actually use it in the transform file? That&rsquo;s where <em>transform context</em> comes in.</p>

<p><a id="2_3"></a></p>

<h2 id="2-3-modules-and-qri">2.3 Modules and <code>qri</code></h2>

<p>Chances are, if you are trying to do something cool with Qri, you will need more than just the basic functionality we&rsquo;ve shown you so far.</p>

<p>You can also import modules from the starlark standard library (<a href="https://github.com/qri-io/starlib">Starlib</a> we have been working on. <a href="../../../docs/reference/starlib">Here</a> is our reference page that details each module and each function within that module.</p>

<p>For now, let&rsquo;s look at the <code>qri</code> module. Here is how you load a module into a transform:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># lol_last_100_matches/transform.star</span>
<span class="n">load</span><span class="p">(</span><span class="s2">&#34;qri.star&#34;</span><span class="p">,</span> <span class="s2">&#34;qri&#34;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">download</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">ds</span></code></pre></div>
<p>Great, now that we&rsquo;ve loaded the <code>qri</code> module, let&rsquo;s actually use it to get the summoner name, region, and api_key, from the dataset.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">download</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
  <span class="n">summoner</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&#34;summoner&#34;</span><span class="p">)</span>
  <span class="n">region</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&#34;region&#34;</span><span class="p">)</span>
  <span class="n">api_key</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">get_secret</span><span class="p">(</span><span class="s2">&#34;api_key&#34;</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="n">summoner</span><span class="p">)</span> <span class="c1"># prints &#34;sørenbjerg&#34;</span>
  <span class="k">print</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="c1"># prints &#34;na1&#34;</span>
  <span class="k">print</span><span class="p">(</span><span class="n">api_key</span><span class="p">)</span> <span class="c1"># prints the api_key</span>

<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">ctx</span><span class="p">):</span>
  <span class="c1"># nothing yet</span></code></pre></div>
<p>Head over to the terminal. Change directories until you are in your <code>lol_last_100_matches</code> folder. We are going to use the <code>--dry-run</code> flag. This will allow us to see the output of the transform, without actually saving it to our Qri node.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">$ qri save --file dataset.yaml me/lol_last_100_matches --secrets=api_key,******** --dry-run</code></pre></div>
<p><a id="2_4"></a></p>

<h2 id="2-4-http-module">2.4 http module</h2>

<p>Now that we can get config and secrets variables, let&rsquo;s use those to grab some data from an API endpoint using the http package.</p>

<p>The http package can only be used in the <code>download</code> function. You do not have access to the network in any the <code>transform</code> function. If you try to download something in the <code>transform</code> function, you will get an error.</p>

<p>You have access to the <code>get</code>, <code>put</code>, <code>post</code>, <code>delete</code>, <code>patch</code>, and <code>options</code> methods from the <code>http</code> module. We are going to use the <code>get</code> method to grab some json for the Riot Games json api.</p>

<p>Note: you can use the <code>text</code>, <code>content</code>, and <code>json</code> methods on a response to get the response body. <code>text</code> and <code>content</code> will return a string representation, <code>json</code> will convert it to json. Please see the <a href="../../../docs/reference/starlib">starlib reference page</a> for more info.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">load</span><span class="p">(</span><span class="s2">&#34;qri.star&#34;</span><span class="p">,</span> <span class="s2">&#34;qri&#34;</span><span class="p">)</span>
<span class="n">load</span><span class="p">(</span><span class="s2">&#34;http.star&#34;</span><span class="p">,</span> <span class="s2">&#34;http&#34;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">download</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
  <span class="c1"># get config and secrets variables from dataset</span>
  <span class="n">summoner</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&#34;summoner&#34;</span><span class="p">)</span>
  <span class="n">region</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&#34;region&#34;</span><span class="p">)</span>
  <span class="n">api_key</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">get_secret</span><span class="p">(</span><span class="s2">&#34;api_key&#34;</span><span class="p">)</span>
  <span class="c1">#</span>
  <span class="c1"># get response from api endpoint</span>
  <span class="c1">#</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;https://&#34;</span> <span class="o">+</span> <span class="n">region</span> <span class="o">+</span> <span class="s2">&#34;.api.riotgames.com/lol/summoner/v3/summoners/by-name/&#34;</span> <span class="o">+</span> <span class="n">summoner</span> <span class="o">+</span> <span class="s2">&#34;?api_key=&#34;</span> <span class="o">+</span> <span class="n">api_key</span><span class="p">)</span>
  <span class="c1">#</span>
  <span class="c1"># get json from body, get accountId from json</span>
  <span class="c1"># note: when the response gets converted to json, it automatically gives the </span>
  <span class="c1"># accountId and id fields a float type. If we were to convert straight to </span>
  <span class="c1"># a string, it would appear in scientific notation. To combat this, I am </span>
  <span class="c1"># casting it to int type, before finally settling on string type.</span>
  <span class="c1">#</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
  <span class="n">accountId</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&#34;accountId&#34;</span><span class="p">]))</span>
  <span class="c1">#</span>
  <span class="c1"># get match data and set as the body of the dataset</span>
  <span class="c1">#</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;https://&#34;</span> <span class="o">+</span> <span class="n">region</span> <span class="o">+</span> <span class="s2">&#34;.api.riotgames.com/lol/match/v3/matchlists/by-account/&#34;</span> <span class="o">+</span> <span class="n">accountId</span> <span class="o">+</span> <span class="s2">&#34;?api_key=&#34;</span> <span class="o">+</span> <span class="n">api_key</span><span class="p">)</span>
  <span class="c1">#</span>
  <span class="c1"># the response is a python dictionary with the dictionary key &#34;matches&#34;</span>
  <span class="c1"># that points to a list of dictionaries. Each item in the list contains </span>
  <span class="c1"># information on a specific match. We only want to keep the actual list</span>
  <span class="c1"># of matches:</span>
  <span class="c1">#</span>
  <span class="n">matches</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s2">&#34;matches&#34;</span><span class="p">]</span>
  <span class="k">print</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="c1"># prints a long list of dictionaries containing match data</span>
  <span class="k">return</span> <span class="n">matches</span>

<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
  <span class="c1"># get matches from context</span>
  <span class="n">matches</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">download</span>
  <span class="c1"># set the body to our matches data</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">set_body</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span></code></pre></div>
<p>First double check that this works by running</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">$ qri save --file dataset.yaml --secrets=api_key,****** --dry-run
🏃🏽‍♀️ dry run
🤖 executing transform
📡 running download...
⚙️  running transform...
# HERE THE OUTPUT OF THE `print(matches)` CALL
✅ transform complete
created new dataset me/league_player_matches@QmTXF6LzpCFK87Ykq7WR7hjzCvNXWGXZ2ssJZwRiPiMSN9/map/QmV9jSavMgEFnC2METNKUvJLb4sVvoMTf6EthuAKmqzbfg</code></pre></div>
<p>If you are running into problems, double check that your api key is up to date!</p>

<p>To get this dataset into your qri node, run the same command, without the <code>--dry-run</code> flag.</p>

<p><a id="2_4"></a></p>

<h2 id="2-4-html-module">2.4 html module</h2>

<p>Let&rsquo;s take a cursory look at the html module. The <code>html</code> module allows you use methods to grab elements from an html page, much like you would using jquery. Take a look at the <a href="../../../docs/reference/starlib">starlib reference page</a> to find out more.</p>

<p>Let&rsquo;s go to wikipedia, and get a list of all the languages that you can read wikipedia in!</p>

<p>We will download the main wikipedia page, parse it using the <code>html</code> method, then navigate down to the <a> element, get the language from the &lsquo;title&rsquo; attribute, and add it to the list of languages.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">load</span><span class="p">(</span><span class="s2">&#34;html.star&#34;</span><span class="p">,</span> <span class="s2">&#34;html&#34;</span><span class="p">)</span>
<span class="n">load</span><span class="p">(</span><span class="s2">&#34;http.star&#34;</span><span class="p">,</span> <span class="s2">&#34;http&#34;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">download</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;https://en.wikipedia.org/wiki/Main_Page&#34;</span><span class="p">)</span>
  <span class="n">doc</span> <span class="o">=</span> <span class="n">html</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">content</span><span class="p">())</span>
  <span class="c1"># from inspecting the contents of the wikipedia page, I was able to </span>
  <span class="c1"># determine that the list of languages was located in a div who&#39;s id </span>
  <span class="c1"># is `#p-lang` </span>
  <span class="n">langElems</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&#34;#p-lang&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&#34;li&#34;</span><span class="p">)</span>
  <span class="n">langs</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">langElems</span><span class="o">.</span><span class="nb">len</span><span class="p">()):</span>
    <span class="c1"># get the ith element in the list of &lt;li&gt;&#39;s</span>
    <span class="n">li</span> <span class="o">=</span> <span class="n">langElems</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="c1"># list of the children of the &lt;li&gt;, in this case it is a list of one</span>
    <span class="c1"># element, an &lt;a&gt; tag</span>
    <span class="n">alist</span> <span class="o">=</span> <span class="n">li</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
    <span class="c1"># There is only one &lt;a&gt; in the list, but it is still a list</span>
    <span class="c1"># to get that first &lt;a&gt; element:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">alist</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
    <span class="c1"># the &#34;title&#34; attribute in the &lt;a&gt; element contains the language, written</span>
    <span class="c1"># in english</span>
    <span class="n">language</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="s2">&#34;title&#34;</span><span class="p">)</span>
    <span class="c1"># append this to the list of languages</span>
    <span class="n">langs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">language</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># this can all be done, alittle more confusingly, in one line:</span>
    <span class="c1"># langs.append(langElems.eq(i).children().first().attr(&#34;title&#34;))</span>
  <span class="k">return</span> <span class="n">langs</span>

<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
  <span class="n">langs</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">download</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">set_body</span><span class="p">(</span><span class="n">langs</span><span class="p">)</span></code></pre></div>
<p>To learn more about our starlark standard library, check out the <a href="../../../docs/reference/starlib">reference page</a> which details each module and all of it&rsquo;s methods.</p>

<!-- <a id="3_0"></a>
## Mixing Manual & Scripted Transforms

### Transform types are mutually exclusive

Both types of transform are acting on the same components and fields of a dataset (`meta` and `body` components, a `title` field and body `rows`). To ensure reproducibility, we need a new rule: **each type of transform must only mutate the dataset in a way that is composable with all other transforms**. This means if both manual and scripted transforms are acting at the same time, only one transform can mutate a field between two snapshots.

With this rule in place, we can finally simplify the question "what is the passed in value of `ds` in `transform(ds,ctx)`?". The answer: the previous snapshot.

In the past, this was complicated. We can now simplify the story because it's an error to have two transform types act on a single field.


Here's an example flow:

`dataset.yaml`:
```yaml
meta:
  title: Prime Ministers of Canada
  description: A list of Canadian Prime Ministers
structure:
  format: json
  schema:
    type: array
    items:
      type: object
      properties:
        name:
          type: string
body: body.json
```

Let's run that through Qri save:
```
# create a new dataset, dataset.yaml contains no transform
$ qri save --file=dataset.yaml me/ca_prime_ministers
created new dataset b5/ca_prime_ministers
```

Pretty quickly we realize that manually constructing the body is a pain, so we write a transform script that grabs this data from a trusted source:

`transform.star`:
```python
load("http.star", "http")

def download(ctx):
  res = http.get("http://canada.ca/prime-ministers-list.json")
  return res.json()

def transform(ds, ctx):
  ds.set_body(ctx.download)
```

So we update our dataset.yaml to specify the transform script:

`dataset.yaml`:
```yaml
meta:
  title: Prime Ministers of Canada
  description: A list of Canadian Prime Ministers
structure:
  format: json
  schema:
    type: array
    items:
      type: object
      properties:
        name:
          type: string
transform:
  script: transform.star
body: body.json
```

But re-running save gives us an error:
```shell
$ qri save --file=dataset.yaml me/ca_prime_ministers
error: transform script and user-supplied dataset are both trying to set:
  body

please adjust either the transform script or remove the supplied body
```

So we do what the error tells us, and remove the `body` field from dataset.yaml, and re-save. This time it works, and the transform runs:

```shell
$ qri save --file=dataset.yaml me/ca_prime_ministers
🤖 executing transform
✅ transform complete
saved dataset b5/ca_prime_ministers
```

Some time later we want to get fresh data, so we run an update:

```shell
$ qri update me/ca_prime_ministers
🤖 executing transform
✅ transform complete
updated dataset b5/ca_prime_minsters
```

Dope. Now we realize that it's important to add themes to our metadata, to classify this info as being about government. In this case we're only trying to set meta, not get a new version of the data. So this time we trust that the data we've already specified is in qri, so we can delete all the stuff about structure in `dataset.yaml`, and just focus on the meta component:

`dataset.yaml`:
```yaml
meta:
  title: Prime Ministers of Canada
  description: A list of Canadian Prime Ministers
  theme:
  - government
  keywords:
  - canada
  - government
  - prime ministers
```

And we save the changes:

```shell
$ qri save --file=dataset.yaml me/ca_prime_ministers
saved dataset b5/ca_prime_minsters
```

The new part here is the transform didn't run, because _save only runs transforms the first time they're provided_. Further proof of this comes from the fact that the transform is now missing from the most recent snapshot:

```
$ qri get transform me/ca_prime_ministers
null
```

Also, `qri update` now gives us a new error:

```
$ qri update me/ca_prime_ministers
error: no transform script in most recent dataset. There is a transform script 2 commits back that adjusts:
  body

to run an update using the most recent transform, run:
  qri update --recall-tf me/ca_prime_ministers
```

This missing transform is vital for reproducibility reasons, the missing transform indicates that no transform script was executed to get from the snapshot that had the old meta to the new meta.

Resurrecting the transform is relatively easy, we follow the instructions from the error:
```
$ qri update --recall-tf me/ca_prime_ministers
🤖 executing transform
✅ transform complete
updated dataset b5/ca_prime_minsters
```

Finally, if we want to both re-run the existing transform _and_ change things about a dataset in a single commit, we can still do that so long as the transform doesn't affect any fields we're trying to manually change by running `qri save with --recall-tf`. In this example we'll adjust the schema to add more specificity, so we adjust dataset.yaml:

`dataset.yaml`:
```yaml
structure:
  format: json
  schema:
    type: array
    items:
      type: object
      properties:
        name:
          type: string
        description:
          type: string
          maxLength: 140
```

And run save with `--recall-tf`:

```
$ qri save --file=dataset.yaml --recall-tf me/ca_prime_ministers
🤖 executing transform
✅ transform complete
updated dataset b5/ca_prime_minsters
```

<a id="1_5"></a>
### Transforms & Histories

A transform is the opposite of a history, moving forwards in snapshots instead of backwards. A history is _reproducible_ when you can start at the first snapshot and re-execute each mutation described in the next snapshot. By enforcing the mutually-exclusive mutations, each snapshot is a deterministic record of both state and _how to arrive at that state_ from the previous snapshot. -->

    </div>
  </section>
</div>
</main>
  <footer></footer>


  <script src="../../../js/kube.js" type="text/javascript">
  </script>
  <script src="../../../js/kube.legenda.js" type="text/javascript">
  </script>
  <script src="../../../js/master.js" type="text/javascript">
  </script>
</body>

</html>
